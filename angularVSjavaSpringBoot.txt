### Arborescence propre pour un projet Angular et Java Spring Boot ###

/mon-projet/
â”‚
â”œâ”€â”€ frontend-angular/                   # Projet Angular (front-end)
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user/
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ user.component.ts       # Composant Angular
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ user.component.html     # Template HTML
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ user.component.scss     # Style SCSS
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.service.ts             # Service HTTP vers API Spring
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ user.ts                     # Interface User (modÃ¨le partagÃ©)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user-status.enum.ts         # Enum partagÃ© (statuts, rÃ´lesâ€¦)
â”‚   â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ format-date.util.ts         # Fonctions utilitaires (ex. affichage)
â”‚   â”‚   â”‚   â””â”€â”€ app.module.ts                   # DÃ©claration des composants/services
â”‚   â”‚   â””â”€â”€ environments/
â”‚   â”‚       â”œâ”€â”€ environment.ts                  # Variables d'environnement (dev)
â”‚   â”‚       â””â”€â”€ environment.prod.ts             # Variables d'environnement (prod)
â”‚   â””â”€â”€ angular.json                            # Configuration Angular CLI
â”‚
â””â”€â”€ backend-springboot/                         # Projet Spring Boot (back-end)
    â”œâ”€â”€ src/
    â”‚   â””â”€â”€ main/
    â”‚       â”œâ”€â”€ java/com/example/
    â”‚       â”‚   â”œâ”€â”€ controller/
    â”‚       â”‚   â”‚   â””â”€â”€ UserController.java       # REST Controller
    â”‚       â”‚   â”œâ”€â”€ service/
    â”‚       â”‚   â”‚   â””â”€â”€ UserService.java          # Logique mÃ©tier
    â”‚       â”‚   â”œâ”€â”€ repository/
    â”‚       â”‚   â”‚   â””â”€â”€ UserRepository.java       # DAO (accÃ¨s base)
    â”‚       â”‚   â”œâ”€â”€ model/
    â”‚       â”‚   â”‚   â”œâ”€â”€ User.java                 # EntitÃ© JPA (modÃ¨le partagÃ©)
    â”‚       â”‚   â”‚   â””â”€â”€ UserStatus.java           # Enum partagÃ© (status, rÃ´lesâ€¦)
    â”‚       â”‚   â”œâ”€â”€ dto/
    â”‚       â”‚   â”‚   â””â”€â”€ UserDTO.java              # Data Transfer Object
    â”‚       â”‚   â”œâ”€â”€ validator/
    â”‚       â”‚   â”‚   â””â”€â”€ UserValidator.java        # Validations personnalisÃ©es
    â”‚       â”‚   â”œâ”€â”€ util/
    â”‚       â”‚   â”‚   â””â”€â”€ DateFormatter.java        # Classe utilitaire (format date, etc.)
    â”‚       â”‚   â””â”€â”€ MonProjetApplication.java     # Classe principale Spring Boot
    â”‚       â””â”€â”€ resources/
    â”‚           â”œâ”€â”€ application.properties        # Configuration Spring
    â”‚           â””â”€â”€ messages.properties           # Messages de validation ou i18n
    â””â”€â”€ pom.xml                                   # DÃ©pendances Maven





Comme vous pouvez le constater, certain concept :
    - Service,
    - model,
    - DTO,
sont ce qu'on appel des "concepts partagÃ©s" entre Angular et Java Spring Boot dont voici une liste presque complÃ¨te (je fais au mieux :p) :

| Concept                         | CÃ´tÃ© Angular (Front-end)                          | CÃ´tÃ© Spring Boot (Back-end)                             | ğŸ” RÃ´le commun ou correspondance 
|---------------------------------|---------------------------------------------------|---------------------------------------------------------|----------------------------------
| **Models / Entities**           | `user.ts` (interface ou classe)                   | `User.java` (entitÃ© JPA ou DTO)                         | ReprÃ©sentent les donnÃ©es Ã©changÃ©es (JSON) 
| **Services**                    | `user.service.ts` (Appels API REST)               | `UserService.java` (Logique mÃ©tier)                     | SÃ©parent la logique mÃ©tier / API 
| **Enums**                       | `user-status.enum.ts`                             | `UserStatus.java` (enum)                                | Valeurs constantes partagÃ©es (ex : rÃ´les, statuts) 
| **Validation**                  | `Validators.required`, `FormGroup`, etc.          | `@Valid`, `@NotNull`, `@Email`, etc.                    | VÃ©rifient la validitÃ© des donnÃ©es saisies 
| **Routing**                     | `RouterModule`, `routes`                          | `@GetMapping("/api/...")`, `@PostMapping(...)`          | GÃ¨rent les chemins (UI cÃ´tÃ© Angular, API cÃ´tÃ© Spring) 
| **Utils / Helpers**             | Fichiers `.util.ts` (formatage, dates, etc.)      | Classes `.java` (utilitaires mÃ©tiers, formatage, etc.)  | Regroupent des fonctions rÃ©utilisables 
| **Configuration**               | `environment.ts`, `environment.prod.ts`           | `application.properties` ou `application.yml`           | DÃ©finissent des variables par environnement 
| **DTOs (modÃ¨les de transfert)** | Interfaces TypeScript pour formulaire ou API      | Classes Java `UserDTO`                                  | ReprÃ©sentent les objets Ã©changÃ©s sans exposer les entitÃ©s internes 
| **Formulaires / Champs**        | `FormControl`, `ReactiveFormsModule`              | `@RequestBody`, `@ModelAttribute`, `BindingResult`      | Transfert de donnÃ©es utilisateur 





Pour vous aider comprendre les diffÃ©rences sur le concept partagÃ© le plus important (d'aprÃ¨s moi), je vais vous expliquer la diffÃ©rence entre un service Angular et un service JavaSB :

1. Le service Angular :

    - Fait des appels HTTP (GET, POST, etc.) vers des endpoints REST exposÃ©s par Spring Boot. 
    
    Ex :

        // Angular
        user.service.ts â†’ http.get('/api/users')



2. Le contrÃ´leur Spring Boot (@RestController)

    - ReÃ§oit la requÃªte HTTP venant dâ€™Angular.
    - Il ne communique pas directement avec la base de donnÃ©es.
    - Il dÃ©lÃ¨gue Ã  un service Java (@Service) pour appliquer la logique mÃ©tier.

    Ex :

        // Spring Boot
        UserController.java â†’ appelle â†’ UserService.java



3. Le service Java Spring Boot (@Service)

    - Contient la logique mÃ©tier.
    - Il utilise un repository (UserRepository) pour accÃ©der Ã  la base de donnÃ©es.

    Ex :

        UserService.java â†’ appelle â†’ UserRepository.java â†’ base de donnÃ©es



RÃ©sumÃ© visuel :

    [Angular Service]
            â†“ HTTP
    [Spring Boot Controller]
            â†“ mÃ©thode Java
    [Spring Boot Service]
            â†“ mÃ©thode Java
    [Spring Boot Repository]
            â†“ accÃ¨s
    [Base de donnÃ©es]



Pourquoi cette structure est importante :

    - Le contrÃ´leur ne fait que recevoir la requÃªte et rediriger vers le bon service.
    - Le service Java gÃ¨re toute la logique mÃ©tier (ex : vÃ©rifier quâ€™un email est unique, etc.).
    - Le repository fait uniquement le lien avec la base de donnÃ©es (via Spring Data JPA).





### CONNEXION ANGULAR AVEC JAVA SB ###

Angular ne se connecte pas directement Ã  Spring Boot, il consomme les API exposÃ©es par les @RestController de Spring Boot.
    Autrement dit :

        - Spring Boot expose des endpoints HTTP grÃ¢ce aux @RestController (par exemple, GET /api/patients),
        - Angular envoie des requÃªtes HTTP (via HttpClient) pour consommer ces endpoints,
        - Et la communication se fait par des API RESTful (JSON en gÃ©nÃ©ral).

    En rÃ©sumÃ© :

        - @RestController = Point dâ€™entrÃ©e cÃ´tÃ© backend pour les requÃªtes HTTP.
        - HttpClient (Angular) = Client HTTP qui fait des appels vers ces points dâ€™entrÃ©e.



1. CrÃ©er le Backend Spring Boot (API REST)

    Exemple de contrÃ´leur REST :

        @RestController
        @RequestMapping("/api/patients")
        public class PatientController {

            @GetMapping
            public List<String> getAllPatients() {
                return List.of("Jean Dupont", "Marie Curie");
            }

            @PostMapping
            public String addPatient(@RequestBody String patientName) {
                // Sauvegarde en base fictive
                return "Patient ajoutÃ© : " + patientName;
            }
        }

Endpoint GET : http://localhost:8080/api/patients
Endpoint POST : http://localhost:8080/api/patients



2. Configurer CORS dans Spring Boot (pour accepter les appels du frontend)

        @Configuration
        public class CorsConfig {
            @Bean
            public WebMvcConfigurer corsConfigurer() {
                return new WebMvcConfigurer() {
                    @Override
                    public void addCorsMappings(CorsRegistry registry) {
                        registry.addMapping("/api/**")
                                .allowedOrigins("http://localhost:4200") // Port de l'app Angular
                                .allowedMethods("GET", "POST", "PUT", "DELETE");
                    }
                };
            }
        }



3. CrÃ©er le Frontend Angular

    Exemple de service pour consommer les endpoints :

        import { Injectable } from '@angular/core';
        import { HttpClient } from '@angular/common/http';
        import { Observable } from 'rxjs';

        @Injectable({
        providedIn: 'root'
        })

        export class PatientService {   
            private apiUrl = 'http://localhost:8080/api/patients';

            constructor(private http: HttpClient) {}

            getPatients(): Observable<string[]> {
            return this.http.get<string[]>(this.apiUrl);
            }

            addPatient(name: string): Observable<string> {
            return this.http.post<string>(this.apiUrl, name);
            }
        }


    Exemple de consommation dans un composant :

        import { Component, OnInit } from '@angular/core';
        import { PatientService } from 'src/app/services/patient.service';

        @Component({
            selector: 'app-patient-list',
            template: `
            <h2>Liste des patients</h2>
            <ul>
            <li *ngFor="let patient of patients">{{ patient }}</li>
            </ul>
            <input [(ngModel)]="newPatient" placeholder="Nom du patient" />
            <button (click)="addPatient()">Ajouter</button>
            `
        })

        export class PatientListComponent implements OnInit {
            patients: string[] = [];
            newPatient: string = '';

            constructor(private patientService: PatientService) {}

            ngOnInit() {
                this.loadPatients();
            }

            loadPatients() {
                this.patientService.getPatients().subscribe(data => this.patients = data);
            }

            addPatient() {
                this.patientService.addPatient(this.newPatient).subscribe(response => {
                console.log(response);
                this.loadPatients();
                });
            }
        }



4. Ne pas oublier dâ€™importer HttpClientModule dans app.module.ts :

    import { HttpClientModule } from '@angular/common/http';
    @NgModule({
        declarations: [/* components */],
        imports: [BrowserModule, HttpClientModule],
        bootstrap: [/* AppComponent */]
    })
    export class AppModule {}



5. DÃ©marrer les deux projets

    Backend Spring Boot :
        mvn spring-boot:run

    Frontend Angular :
        ng serve



En rÃ©sumÃ© :

    - Le frontend utilise HttpClient pour faire des requÃªtes HTTP vers les endpoints du backend.
    - Le backend expose des endpoints REST via @RestController.
    - CORS doit Ãªtre configurÃ© pour permettre la communication entre deux serveurs diffÃ©rents.